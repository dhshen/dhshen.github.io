
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Git学习笔记 | 向上爬的蜗牛</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="dhshen">
    

    
    <meta name="description" content="廖雪峰的Git教程学习笔记 Git简介Git是分布式版本控制系统。SVN是集中式版本控制系统，而Git则是分布式版本控制系统。  集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再">
<meta name="keywords" content="Git">
<meta property="og:type" content="article">
<meta property="og:title" content="Git学习笔记">
<meta property="og:url" content="https://dhshen.github.io/2016/09/05/Git学习笔记/index.html">
<meta property="og:site_name" content="向上爬的蜗牛">
<meta property="og:description" content="廖雪峰的Git教程学习笔记 Git简介Git是分布式版本控制系统。SVN是集中式版本控制系统，而Git则是分布式版本控制系统。  集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://i.loli.net/2017/12/05/5a263cdddbceb.jpg">
<meta property="og:image" content="http://www.liaoxuefeng.com/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0">
<meta property="og:image" content="http://www.liaoxuefeng.com/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0">
<meta property="og:updated_time" content="2018-01-15T11:51:16.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Git学习笔记">
<meta name="twitter:description" content="廖雪峰的Git教程学习笔记 Git简介Git是分布式版本控制系统。SVN是集中式版本控制系统，而Git则是分布式版本控制系统。  集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再">
<meta name="twitter:image" content="https://i.loli.net/2017/12/05/5a263cdddbceb.jpg">

    
    <link rel="alternative" href="/atom.xml" title="向上爬的蜗牛" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="向上爬的蜗牛">向上爬的蜗牛</a></h1>
				<h2 class="blog-motto">记录搬砖路上的点点滴滴</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">首页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:dhshen.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/09/05/Git学习笔记/" title="Git学习笔记" itemprop="url">Git学习笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="dhshen" target="_blank" itemprop="author">dhshen</a>
		
  <p class="article-time">
    <time datetime="2016-09-05T05:14:13.000Z" itemprop="datePublished"> 发表于 2016-09-05</time>
    
  </p>
</header>
	<div class="article-content">
		
		<p><a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">廖雪峰的Git教程</a>学习笔记</p>
<h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git是分布式版本控制系统。<br>SVN是集中式版本控制系统，而Git则是分布式版本控制系统。</p>
<blockquote>
<p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
</blockquote>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，不得把人给憋死啊.</p>
<blockquote>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了</p>
</blockquote>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库。分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
<h2 id="git的安装和配置"><a href="#git的安装和配置" class="headerlink" title="git的安装和配置"></a>git的安装和配置</h2><p>在windows下安装了git后，在开始菜单里找到Git Bash，弹出一个命令行的窗口，说明git安装成功了。</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>
<p>因为git是分布式版本控制系统，因此每个机器都必须自报家门：你的名字和Email地址。<br>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库又名仓库，英文名<strong>repository</strong>，可以简单的理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以跟踪历史，或者“还原”。</p>
<ol>
<li>创建一个空目录<code>mygit</code></li>
<li>在git bash下进入该目录，执行<font color="red"><code>git init</code></font>，该命令把这个目录变成Git可以管理的<strong>仓库</strong>。执行该命令后会发现当前目录下多了一个.git目录，这个目录是Git用来跟踪管理版本库的，不能随便去改动它。</li>
<li><strong>把文件添加到版本库</strong><br>在mygit目录下添加test.txt,用notpadd++编辑一些文字在里面并保存。<br>执行命令<code>git add test.txt</code>，没有任何显示，Unix的哲学是“没有消息就是好消息”。</li>
<li>用命令<font color="red"><code>git commit</code></font>告诉git，把文件提交到仓库。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add a test file&quot;</span><br></pre></td></tr></table></figure>
<p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，相当于svn的日志。</p>
<p>在windows下执行第3步时会出现<font color="blue"><code>warning: LF will be replaced by CRLF</code></font>,这是因为：windows中的换行符为 CRLF， 而在linux下的换行符为LF，解决的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf .git	//删除之前生成的.git</span><br><span class="line">$ git config --global core.autocrlf false  //禁用自动转换</span><br></pre></td></tr></table></figure>
<p>然后重新执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add test.txt</span><br></pre></td></tr></table></figure>
<p><a href="http://blog.csdn.net/unityoxb/article/details/20768687" target="_blank" rel="noopener">windows使用git时出现：warning: LF will be replaced by CRLF</a></p>
<h2 id="git-status和git-diff命令"><a href="#git-status和git-diff命令" class="headerlink" title="git status和git diff命令"></a>git status和git diff命令</h2><font color="red"><code>git status</code></font> 可以告诉你有没有文件被修改过<br><font color="red"><code>git diff</code></font> 可以查看修改的内容：<code>git diff test.txt</code><br><br>## 版本回退<br><br>每一次执行git commit时，git便会“保存一个快照”，这个快照在Git中被称为<code>commit</code>。<br><br>### git log命令，查看历史记录<br><br>可以看到git的历史记录显示四个字段的信息，分别是：版本号，作者，日期和用户提交的log信息.<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 1f627bd6c5c06d998a8dc457b5be7ddfc54dad24</span><br><span class="line">Author: Exampler &lt;xxxxxxxxx@qq.com&gt;</span><br><span class="line">Date:   Sun Sep 4 11:38:58 2016 +0800</span><br><span class="line"></span><br><span class="line">    add a new line to test.txt</span><br><span class="line"></span><br><span class="line">commit c7bfe9c46d83f5f4fcf9b1696ff6883e6af01c1e</span><br><span class="line">Author: Exampler &lt;xxxxxxxxx@qq.com&gt;</span><br><span class="line">Date:   Sun Sep 4 11:32:22 2016 +0800</span><br><span class="line"></span><br><span class="line">    modify test.txt</span><br><span class="line"></span><br><span class="line">commit 8e1e35cf649305f98bc3f13b0a5568cce50c17e9</span><br><span class="line">Author: Exampler &lt;xxxxxxxxx@qq.com&gt;</span><br><span class="line">Date:   Sun Sep 4 11:10:29 2016 +0800</span><br><span class="line"></span><br><span class="line">    add test.txt to git</span><br></pre></td></tr></table></figure><br><br>如果希望看到简略的日志信息，可以在后面加上<font color="red"><code>--pretty=oneline</code></font>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">1f627bd6c5c06d998a8dc457b5be7ddfc54dad24 add a new line to test.txt</span><br><span class="line">c7bfe9c46d83f5f4fcf9b1696ff6883e6af01c1e modify test.txt</span><br><span class="line">8e1e35cf649305f98bc3f13b0a5568cce50c17e9 add test.txt to git</span><br></pre></td></tr></table></figure>
<h3 id="git-reset命令"><a href="#git-reset命令" class="headerlink" title="git reset命令"></a>git reset命令</h3><p>在git中<code>HEAD</code>表示当前版本，上一个版本就是<code>head^</code>，上上个版本就是<code>HEAD^^</code>，以此类推。<br><strong>回退到上一个版本：</strong> <code>git reset --hard HEAD^</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at c7bfe9c modify test.txt</span><br></pre></td></tr></table></figure>
<p><strong>回退到指定版本号：</strong> <code>git reset --hard commit-id</code><br>版本号没必要写全，前几位就可以了，Git会自动去找。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向当前版本的指针改为指向指定版本而已，然后顺便把工作区的文件更新了。</p>
<p>Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令,当我们回退了太多时在git log中找不到以前的版本号时可以使用此命令来查找。</p>
<p>总结：</p>
<ol>
<li>用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本</li>
</ol>
<h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其它版本控制系统不同之处就是有暂存区的概念。<br>名词解释</p>
<ul>
<li>工作区<br>就是在电脑里能看到的目录，比如上面新建的mygit文件夹就是一个工作区。</li>
<li>版本库<br>工作区有一个隐藏的目录.git，这个不算工作区，而是Git的版本库。<br> Git的版本库里存了很多东西，其中最重要的就是称为stage或index的<font color="red"><strong>暂存区</strong></font>，还有Git为我们自动创建的第一个分支master，以及指向master的HEAD指针。</li>
</ul>
<p>前面我们把文件往Git版本库里添加的时候，是分为两步执行的：<font color="red"></font></p>
<ol>
<li>用<code>git add</code>命令把文件添加进去，<strong>实际上就是把文件修改添加到暂存区！</strong></li>
<li>用<code>git commit</code>提交更改，<strong>实际上就是把暂存区的所有内容提交到当前分支！</strong><br></li>
</ol>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以现在<code>git commit</code>就是往master分支上提交更改。<br>你可以理解为：需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改。</p>
<p><img src="https://i.loli.net/2017/12/05/5a263cdddbceb.jpg" alt="工作区和暂存区-廖雪峰的博客图"></p>
<h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>为什么Git比其他版本控制系统更优秀？因为Git跟踪并管理的是修改，而非文件。<br>举个栗子：</p>
<ol>
<li>修改test.txt中的内容</li>
<li>执行<code>git add test.txt</code></li>
<li>再次修改test.txt的内容</li>
<li>执行<code>git commit</code></li>
</ol>
<p>最终的结果是第一次修改的内容得到了提交，而第二次修改的内容并没有被提交。<br>因为<code>git add</code>命令只是将第一次修改放入暂存区，第二次修改并没有执行<code>git add</code>命令，因此第二次修改不会放入暂存区，<code>git commit</code>只负责把暂存区的内容提交了。</p>
<p>提交后可以用<font color="red"><code>git diff HEAD -- test.txt</code></font>命令查看工作区和版本库里面最新版本的区别。</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p><code>git checkout -- filename</code>命令可以丢弃文件在工作区的修改，分为两种情况：</p>
<ol>
<li>修改的文件还没有添加到暂存区，则文件恢复为当前版本中的状态。</li>
<li>修改的文件已经添加到暂存区，则文件恢复成暂存区中的状态。</li>
</ol>
<p>如果已经将修改的文件添加到了暂存区，可以使用命令<code>git reset HEAD filename</code>将暂存区的该文件撤销掉。</p>
<p>小结：</p>
<ol>
<li>丢弃工作区的所有修改：<code>git checkout -- filename</code></li>
<li>丢弃暂存区的修改：<code>git reset HEAD filename</code></li>
</ol>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>当删除工作区的某个文件时，git status会提示工作区与版本库不一致，因为删除也是一次修改操作。</p>
<ol>
<li>如果希望从版本库中也删除该文件，那么使用<code>git rm filename</code>删掉版本库中的该文件。</li>
<li>如果是删错了，希望将误删文件恢复到最新版本，则执行<code>git checkout -- filename</code></li>
</ol>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以一键还原。</p>
<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器,但是一开始为了学习，我们可以使用GitHub。</p>
<p>GitHub是一个提供Git仓库托管服务的，只要注册GitHub账号，就可以免费获得Git远程仓库。</p>
<p>由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，因此需要一点设置：</p>
<ol>
<li>创建SSH Key<br>执行命令 <code>ssh-keygen -t rsa -C &quot;youremail@something.com&quot;</code><br> 然后一路回车，通通都使用默认值即可。<br> 在用户主目录里(windows下为/c/User/用户/)找到.ssh目录，里面会有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的密钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥。</li>
<li>登陆GitHub，打开“Settings”，在“SSH and GPG keys”栏中点击“New SSH Key”，然后随便填写一个标题，将id_rsa.pub中的内容复制到Key那一栏种，然后点击“Add SSH Key”按钮添加SSH Key。</li>
</ol>
<p>为什么GitHub需要SSH Key呢？<br>因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，就可以确认只有你自己才能推送。<br>GitHub允许添加多个Key，假设你有若干台电脑，就可以在每台电脑上往GitHub推送了。</p>
<h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>在Github上“New Repository”创建一个新的仓库。<br>在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。</p>
<p>目前在GitHub上的这个learngit仓库还是空的，GitHub提示我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联。(见创建成功后的页面)</p>
<p>根据git的提示，在本地的learngit仓库下运行如下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/Exampler/learngit.git</span><br><span class="line">也可以使用：</span><br><span class="line">$ git remote add origin git@github.com:Exampler/learngit.git</span><br><span class="line">使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https.</span><br></pre></td></tr></table></figure>
<p>本地仓库就关联了GitHub的远程库.</p>
<p>添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</p>
<p>接下来我们就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>
<p>在弹出的提示框中输入github的账户和密码本地库的内容就推送到远程库上去了。<br>用git push命令，实际上是把当前分支<code>master</code>分支推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上<code>-u</code>参数，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>从现在起，只要本地做了提交，就可以通过命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>把本地master分支的最新修改推送至GitHub。</p>
<p>修改<code>git remote</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;git_remote_url&gt;</span><br></pre></td></tr></table></figure>
<h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>上面讲的都是先有本地库，后有远程库的时候，如何关联远程库。假设我们从零开始，那么最好的方式是先创建远程库，然后从远程库克隆。</p>
<p>用<strong><code>git clone</code></strong>命令克隆一个远程库到本地库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在本地用来放置克隆下来的库的目录下执行如下命令：</span><br><span class="line">$ git clone git@github.com:Exampler/learngit.git</span><br></pre></td></tr></table></figure>
<h3 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h3><p>当第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The authenticity of host &apos;github.com (192.30.253.113)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)? yes</span><br><span class="line">Warning: Permanently added &apos;github.com,192.30.253.113&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure>
<p>这是因为SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支在实际中有什么作用呢？<br>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码会导致别人不能干活了。如果等代码全部写完再提交一次，又存在丢失每天进度的巨大风险。</p>
<p>有了分支就不用怕了，你创建一个属于自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样既安全又不影响别人工作。</p>
<h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>一开始，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点。每次提交，master分支都会向前移动一步。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上。从此，对工作区内容的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变。</p>
<p>加入我们在dev上的工作完成了，就可以把dev合并到master上，Git怎么合并呢？最简单的方法就是直接把master指向dev的当前提交，就完成了合并。所以Git合并分支也很快！</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch dev</span><br></pre></td></tr></table></figure>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure>
<h3 id="创建并切换到新分支"><a href="#创建并切换到新分支" class="headerlink" title="创建并切换到新分支"></a>创建并切换到新分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br></pre></td></tr></table></figure>
<h3 id="查看当前分支"><a href="#查看当前分支" class="headerlink" title="查看当前分支"></a>查看当前分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch	//会列出所有分支，当前分支前面会标一个*号</span><br></pre></td></tr></table></figure>
<p>切换分支为dev后修改test.txt文件并提交到dev分支，再切换回master分支时工作区的文件是修改之前的状态。因为此时的分支状态为下图所示：<br><img src="http://www.liaoxuefeng.com/files/attachments/001384908892295909f96758654469cad60dc50edfa9abd000/0" alt="image from liaoxuefeng.com"></p>
<p>现在，我们把dev分支的工作成果合并到master分支上：</p>
<h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev		//用于合并指定分支到当前分支</span><br></pre></td></tr></table></figure>
<p><code>git merge</code>是用于合并指定的分支到<strong>当前分支！！！</strong></p>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br></pre></td></tr></table></figure>
<p>因为创建、合并和删除分支非常快，因此Git鼓励使用分支完成某个人物，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但是过程更加安全。</p>
<h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>用<font color="red"><code>git log --graph</code></font>命令可以看到分支合并图。</p>
<h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，Git会用<font color="red"><code>Fast forward</code></font>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<font color="red"><code>Fast forward</code></font>模式，Git就会在merge时生成一个新的commit，这样，从分支历史就可以看出分支信息。</p>
<p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure>
<p>因为本次合并要会创建一个新的commit，所以加上-m参数把描述写进去。</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：<br>首先：master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活。<br>那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。<br>团队合作的分支看起来就像是这样：<br><img src="http://www.liaoxuefeng.com/files/attachments/001384909239390d355eb07d9d64305b6322aaf4edac1e3000/0" alt="from liaoxuefeng.com"></p>
<h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>在Git中，由于分支十分的强大，每个bug都可以通过一个新的临时分支来修复，修复后合并分支并将临时分支删除。</p>
<p>当你需要修复一个bug时，当前正在dev上进行的工作还没有提交，而且工作进行到一半，你还没法提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shendh@dh-PC MINGW32 /d/Git/learngit (dev)</span><br><span class="line">$ git checkout master</span><br><span class="line">error: Your local changes to the following files would be overwritten by checkout:</span><br><span class="line">        test.txt</span><br><span class="line">Please, commit your changes or stash them before you can switch branches.</span><br><span class="line">Aborting</span><br></pre></td></tr></table></figure>
<p>如果此时选择切换分支，会提示上面所示的错误，因为dev分支还没有提交，如果切换分支的话会导致现在正在工作区中的dev分支的文件被覆盖，造成工作内容的丢失，因此Git是禁止用户这样操作的，而且提示中也告诉用户需要<code>commit</code>或者<code>stash</code>之后才可以切换。那么什么是<code>stash</code>呢？</p>
<p>Git提供了<code>stash</code>功能，可以把当前工作现场“存储起来”，等以后恢复现场后继续工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 185ff3b merge with no-ff</span><br><span class="line">HEAD is now at 185ff3b merge with no-ff</span><br></pre></td></tr></table></figure>
<p>现在用<code>git status</code>查看工作区，就是干净的，也就是说可以切换分支了。比方说我们需要在master分支上修复bug，就从master分支创建临时分支，修复完成后，切换到master分支，完成合并后删除临时分支。<br>我们再切回dev分支：<code>git checkout dev</code>，此时工作区是干净的，刚才的工作现场还没有恢复出来。<br>使用<code>git stash list</code>命令查看保存的工作现场列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 185ff3b merge with no-ff</span><br></pre></td></tr></table></figure>
<p>怎么恢复工作现场呢？</p>
<ol>
<li>用<code>git stash apply</code>恢复，但回复后，stash内容并不删除，还需要用<code>git stash drop</code>来删除。</li>
<li>用<code>git stash pop</code>,恢复的同时把stash内容也删了。</li>
</ol>
<p>我们也可以恢复制定的stash，用命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>应用场景：在软件开发中，总是有无穷无尽的新功能要被添加进来。<br>添加一个新功能时，不希望因为一些实验性质的代码把主分支搞乱，所以，每添加一个新功能，最好新建一个feature分支。<br>如果一个分支开发完后你不想将它与dev或master分支合并，而是想直接删除它怎么做呢？<br>如果使用<code>git branch -d feature-test</code>命令，Git会提示销毁失败，因为此分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令<font color="red"><code>git branch -D feature-test</code></font>。</p>
<h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。<br>查看远程库的信息：<code>git remote</code>或<code>git remote -v</code>显示更详细信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Exampler/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:Exampler/learngit.git (push)</span><br></pre></td></tr></table></figure>
<p>上面显示了可以抓取和推送的<code>origin</code>地址，如果没有推送权限，就看不到push地址。</p>
<h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。<br>推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>如果要推送其他分支，比如dev，则是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>
<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<ul>
<li>master分支是主分支，因此要时刻与远程同步；</li>
<li>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li>
<li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li>
<li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li>
</ul>
<h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>当从远程库clone时，默认情况下，只能看到本地的master分支。如果想在dev分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure>
<p>现在就可以在dev分支上继续修改，然后把dev分支push到远程。</p>
<p>你的小伙伴向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件做了修改，并试图推送。推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送：<font color="red"></font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure>
<p></p>
<p>如果<code>git pull</code>失败，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示设置dev和origin/dev的链接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream dev origin/dev</span><br><span class="line">Branch dev set up to track remote branch dev from origin.</span><br></pre></td></tr></table></figure>
<p>再pull成功，但是合并有冲突，需要手动解决冲突。解决后，提交，再push</p>
<p>小结多人协作的工作模式：</p>
<ol>
<li>首先，试图用<code>git push origin branch-name</code>推送自己的修改；</li>
<li>如果推送失败，则是因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或解决冲突后，再用<code>git push origin branch-name</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<font color="blue">“no tracking information”</font>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream branch-name origin/branch-name</code>。</p>
<h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针，所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？<br>因为commit的id号不好记啊，相反tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上，然后敲命令：<font color="red"></font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p><br>就可以打一个新的标签了，可以用命令<font color="red"><code>git tag</code></font>查看所有标签。<br>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，可以找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.2 6224937</span><br></pre></td></tr></table></figure>
<p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v1.2 -m &quot;create v1.2 tag&quot; 6224937</span><br></pre></td></tr></table></figure>
<p>标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息.</p>
<h2 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h2><p>如果标签打错了，可以删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure>
<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure>
<p>或者一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure>
<p>如果标签已经推送到远程，要删除远程标签的话，先删除本地标签，然后远程删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tagname&gt; </span><br><span class="line">$ git push origin :refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure>
<h1 id="使用GitHub"><a href="#使用GitHub" class="headerlink" title="使用GitHub"></a>使用GitHub</h1><h1 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h1><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，每次<code>git status</code>都会显示<code>Untracked files ...</code><br>在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test.ini	//忽略test.ini文件</span><br><span class="line">*.db		//忽略所有.db后缀的文件</span><br><span class="line">dist		//忽略dist目录</span><br></pre></td></tr></table></figure>
<font color="red">使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会提示必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</font>

<p>如果你确实想添加该文件，可以用 <font color="red"><code>-f</code></font> 强制添加到Git。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理</p>
<h2 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h2><p>以centos为例.参考自<a href="http://blog.csdn.net/wave_1102/article/details/47779401" target="_blank" rel="noopener">csdn</a></p>
<ol>
<li>首先安装Git(阿里云的centos系统可能已经自动安装好了Git)，可以使用yum在线安装：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y git</span><br></pre></td></tr></table></figure>
<ol>
<li>创建一个git用户，专门用来运行git服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化git仓库：比如我们选择/home/git/learngit.git来作为我们的git仓库。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init --bare learngit.git</span><br></pre></td></tr></table></figure>
<p>这条命令会在<code>/home/git/</code>目录下生成<code>learngit.git</code>文件夹</p>
<ol>
<li>将<code>learngit.git</code>的owner改为git:<font color="red"></font></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R git:git learngit.git</span><br></pre></td></tr></table></figure>
<p><br><code>-R</code>参数非常重要，表示此文件夹及其下属的文件都应用此权限，一开始配置的时候少加了-R，后面在提交代码的时候会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Counting objects: 140, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (139/139), done.</span><br><span class="line">fatal: Unable to create temporary file: Permission denied</span><br><span class="line">fatal: sha1 file &apos;&lt;stdout&gt;&apos; write error: Broken pipe</span><br><span class="line">error: failed to push some refs to &apos;git@ip:/home/git/learngit.git&apos;</span><br></pre></td></tr></table></figure>
<ol>
<li>Git服务器打开RSA认证<br>在Git服务器上首先需要将<code>/etc/ssh/sshd_config</code>中将RSA认证打开，即：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RSAAuthentication yes     </span><br><span class="line">PubkeyAuthentication yes     </span><br><span class="line">AuthorizedKeysFile  .ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到公钥存放在.ssh/authorized_keys文件中。所以我们在/home/git下创建.ssh目录，然后创建<font color="red">authorized_keys</font>文件。<br>在github中我们需要将ssh公钥添加到SSH Key，在我们的Git服务器上我们则是把公钥放在authorized_keys文件中，一行一个。<br>收集所有需要登录的用户的公钥，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
<ol>
<li>禁用git用户的shell登录<br>处于安全考虑，创建的git用户不允许登录shell，可以通过编辑/etc/passwd文件完成。找到类似下面的一行：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/bin/bash</span><br></pre></td></tr></table></figure>
<p>最后一个冒号后改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>
<p>这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。</p>
<ol>
<li>Git服务器搭建完成！</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@192.168.1.101:/home/git/learngit.git</span><br></pre></td></tr></table></figure>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>一 个bare repo与普通repo的区别是没有项目文件的working copy，即repo根目录下只有专用目录，而没有任何其他代码文件和文件夹；这是为了响应作为codebase应当遵循的“Only store, never update from revisions（只存储版本，不更新到实际代码文件）”原则。<br>如果一个仓库一开始是使用<code>git init</code>初始化的，那么使用如下命令可以将其转换成bare的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --bool core.bare true</span><br></pre></td></tr></table></figure>
<h2 id="1-使用Git来部署线上代码"><a href="#1-使用Git来部署线上代码" class="headerlink" title="1.使用Git来部署线上代码"></a>1.使用Git来部署线上代码</h2><ul>
<li>在服务器端的项目目录下执行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>使项目目录成为一个git目录</p>
<ul>
<li>使服务器端的该Git目录接受push(关键)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config receive.denyCurrentBranch ignore</span><br></pre></td></tr></table></figure>
<ul>
<li>使服务器端每次被push时执行版本设置</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># cd .git/hooks	//进入.git目录中的钩子目录</span><br><span class="line"># ls	//查看钩子目录下文件，这些都是各个钩子对应的文件示例 ( 注意，只是示例！)</span><br><span class="line">applypatch-msg.sample  post-commit.sample  post-update.sample     pre-commit.sample          pre-rebase.sample</span><br><span class="line">commit-msg.sample      post-receive.sample  pre-applypatch.sample  prepare-commit-msg.sample  update.sample</span><br></pre></td></tr></table></figure>
<p>从文件名可以看出钩子被执行的时机，钩子也分为客户端的钩子和服务器端的，比如<code>pre-receive</code>和<code>post-receive</code>就属于Git服务器端(也就是接收push的一方)的钩子。<br>编辑post-receive.sample文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line"># An example hook script for the &quot;post-receive&quot; event.</span><br><span class="line">#</span><br><span class="line"># The &quot;post-receive&quot; script is run after receive-pack has accepted a pack</span><br><span class="line"># and the repository has been updated.  It is passed arguments in through</span><br><span class="line"># stdin in the form</span><br><span class="line">#  &lt;oldrev&gt; &lt;newrev&gt; &lt;refname&gt;</span><br><span class="line"># For example:</span><br><span class="line">#  aa453216d1b3e49e7f6f98441fa56946ddcd6a20 68f7abf4e6f922807889f52bc043ecd31b79f814 refs/heads/master</span><br><span class="line">#</span><br><span class="line"># see contrib/hooks/ for a sample, or uncomment the next line and</span><br><span class="line"># rename the file to &quot;post-receive&quot;.</span><br><span class="line"></span><br><span class="line">#. /usr/share/git-core/contrib/hooks/post-receive-email</span><br><span class="line">unset $(git rev-parse --local-env-vars)</span><br><span class="line">cd /home/git/example</span><br><span class="line">/usr/bin/git reset --hard HEAD</span><br></pre></td></tr></table></figure>
<p>注意最后要将 <code>post-receive.sample</code> 改名成 <code>post-receive</code> ，否则不会生效的，脚本中对这一点也有说明。<br>当本地代码push到服务器上来时就会执行此钩子，将工作区的版本设置成最新的版本，从而实现代码的更新。<br>最后将 post-receive 设置成可执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x .git/hooks/post-receive</span><br></pre></td></tr></table></figure>
<ul>
<li>在本地把项目克隆下来</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@xxx.xxx.com:\home\git\example</span><br></pre></td></tr></table></figure>
<ul>
<li>在本地修改代码后使用<code>git push origin master</code>命令将更新推送到服务器端，更新就自动部署了，这只是针对静态文件的一些设置，如果需要重启nginx服务器之类的根据需求去写钩子脚本文件。</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Git/">Git</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://dhshen.github.io/2016/09/05/Git学习笔记/" data-title="Git学习笔记 | 向上爬的蜗牛" data-tsina="undefined" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2016/09/09/ES6读书笔记/" title="ES6读书笔记">
  <strong>上一篇：</strong><br/>
  <span>
  ES6读书笔记</span>
</a>
</div>


<div class="next">
<a href="/2016/08/06/MongoDB基本操作/"  title="MongoDB基本操作">
 <strong>下一篇：</strong><br/> 
 <span>MongoDB基本操作
</span>
</a>
</div>

</nav>

	


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/python/" title="python">python<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/css/" title="css">css<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Git/" title="Git">Git<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/php/" title="php">php<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/npm/" title="npm">npm<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/charles/" title="charles">charles<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/ES6/" title="ES6">ES6<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/React/" title="React">React<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/svg/" title="svg">svg<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/设计模式/" title="设计模式">设计模式<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/运维/" title="运维">运维<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/mongodb/" title="mongodb">mongodb<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Nginx/" title="Nginx">Nginx<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/基础/" title="基础">基础<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/antd/" title="antd">antd<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/svn/" title="svn">svn<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/http2/" title="http2">http2<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/https/" title="https">https<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/JS/" title="JS">JS<sup>1</sup></a></li>
			
		
		</ul>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="dhshen">dhshen</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
